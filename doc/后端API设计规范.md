|编辑者|编辑时间|编辑内容|
|-|-|
|wcc|2019.2.11|创建文档|

这篇文档不是对后端API的具体描述。本文对所有后端API所遵循的基本原则进行规范，同时涉及部分后端代码，同时适用于前端和后端维护者。

----

所有的后端API均使用GET或POST方法。前端（如axios）可能会发起OPTIONS请求，所以要确保后端同样可以正确处理OPTIONS请求。所有会更新后端状态（除缓存外）的API采用POST方法，其余采用GET方法。

由于前端运行环境限制，所有API均不使用session。用户登录成功时，后端会返回一个一次性的token，在同一时刻同一个token只会下发给一个登录用户，但是一个用户可以拥有多个token。token会在一定时间（如30天）后过期，并在用户注销时收回。用户登录后，发起任何请求均要带上token，后端会识别该token并依此确认发起请求的用户。换言之，除了登录API外，所有API均需要登录后才能使用。

无论是使用GET还是POST方法，请求参数均以json形式传送，以支持丰富的数据类型。POST方法的参数会通过请求体发送，GET方法的参数则以`data={json形式的参数字典}`形式的query string进行传递（特殊字符由前后端框架自动编码解码）。后端中间件`common.middleware.extract_arguments_middleware`将这种形式的参数提取至`request.args`字典中，因此无论是相应GET方法还是POST方法的后端view，均可以通过`request.args`得到传递的参数。

后端的另一个通用中间件是`angel.middleware.login_checker_middleware`。它会检查`request.args`中是否包含`token`字段，如未包含则直接返回「没有登录」错误。然后，它会根据`token`从数据库的`LoginItem`表中找到该token对应的用户对象，并将其注入到`request.angel`属性中。因此后端view可以通过`request.angel`获取发起该请求的用户。该中间件会忽略对登录API的请求。`LoginItem`表由登录API和注销API的view共同维护。以上业务逻辑意味着，对任意API的请求一定会触发一次对`LoginItem`表的读操作，未来应考虑将该表使用缓存进行优化。

后端提供的所有API均返回一个json字典。该字典总是具有`status`和`message`两个字段。`status`的值为整数，`0`代表正常，`1`代表出错。这里的出错是只「前端采用的错误的方式与后端交互」，一个正确编写的前端，在与后端交互的过程中，绝不应该得到任何一个`status`为`1`的返回。因为，`status`为`1`通常预示着bug或黑客攻击。`status`为`2`为token已过期的情况，在绝大多数情况下也不应该出现。一旦出现，前端就应该先重新登录再继续发起请求。

当`status`为`0`时`message`字段的值恒为`"ok"`。在`status`不为`0`时，`message`字段简短地描述了所发生的异常情况。注意，`message`字段主要用于前端调试，不应当被直接展示给终端用户。

除了`status`和`message`，大多数API还会包含`data`字段，该字段中包含实际的数据内容，其值可能为字典也可能为列表。少数API，如注销当前账号，没有需要返回的数据，因此没有`data`字段。

前端封装库`lib/request.js`提供了向后端发起请求的简单接口，在登录和注销时会操作储存在前端设备上的token文件，使得用户登陆后再次打开应用时不需要重新登录。后端的常用功能模块`common`中提供了`ok`和`error`函数，可以方便地生成正常和出错的返回。
